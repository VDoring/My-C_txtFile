// https://citynetc.tistory.com/64?category=606228 (1)
// https://citynetc.tistory.com/72?category=606228 (2)

// 1. [!]포인터는 변수이고, 배열은 상수이다.
int a[5] = { 0,1,2,3,4 };
int b = 10;
a = &b; //a는 상수이기때문에 오류가 발생. 만약 a가 변수였다면 작동한다.




// 2. 포인터가 가리키는 변수를 상수화시키는 법
int a = 10;
const int *p = &a;
*p = 30; //에러 발생!
a = 30; //가능

//const는 변수를 상수화(변하지 않으며, 고정된 수)시키는 역할을 한다.
// [!] 포인터가 상수화가 되는것이지 변수가 상수화가 되는것이 아니다!
//     (변수 a는 언제든지 변경 가능하나, 포인터 p를 통해 변수 a값을 변경하는 것만 막을 수 있다)




// 3. 포인터를 배열의 이름처럼 사용하기
int arr[3] = { 1,2,3 };
int *ptr;

ptr = arr; //포인터 ptr은 배열 모두를 가리키는게 아닌 arr[0]을 가리키게 된다.

printf("%d, %d, %d", ptr[0], ptr[1], ptr[2]); //1, 2, 3 출력




// 4. 포인터연산 및 자료형과의 관계
int *ptr1 = 0;
char *ptr2 = 0;
double *ptr3 = 0;

printf("%d번지, %d번지, %d번지\n", ptr1++, ptr2++, ptr3++); //0번지, 0번지, 0번지  (초기값)
printf("%d번지, %d번지, %d번지\n", ptr1, ptr2, ptr3); //4번지, 1번지, 8번지

//각 포인터들이 타입에 맞게 4,1,8byte씩 증가했다는 걸 알 수 있다




// 5.
int arr[5] = { 1,2,3,4,5 };

int *pArr = arr;

printf("%d\n", *pArr); // 1 출력. 첫번째 요소 arr[0]을 나타낸다

printf("%d\n", *(++pArr)); // 2 출력. arr[1]로 배열을 증가시키고 출력한다.
printf("%d\n", *(++pArr)); // 3 출력. arr[2]로 배열을 증가시키고 출력한다.

printf("%d\n", *(pArr+1)); // 4 출력. *(pArr+n)의 의미 = 포인터 pArr이 가리키는 곳에서 n칸 건너편에 있는 요소의 값을 참조한다.
printf("%d\n", *(pArr+2)); // 5 출력. 위에문장을 참고해서 pArr이 가리키는 곳에서 2칸 건너편이므로 5이다.




// 6. arr[i] == *(arr+i)이다. 배열의 이름을 포인터처럼 사용하기
int arr[2] = { 1,2 };
int *pArr = arr;

printf("%d, %d\n", arr[0], *(arr + 1)); //배열이름을 통한 출력(배열 이름을 포인터처럼 사용)

printf("%d, %d\n", pArr[0], *(pArr + 1)); //포인터변수를 통한 출력(포인터를 배열이름처럼 사용)

// arr[3]은 *(arr+3)과 같은 의미다. arr이 배열이든 포인터이든 상관없고, 1차원배열이든 2차원배열이든 항상 성립한다.




// 7. 포인터가 표현하는 문자열 상수
char str[5] = "abcd";
char *pStr[5] = "ABCD"; //문자 ABCD를 가리킨다

// 배열의 경우)
str[0] = a
str[1] = b
str[2] = c
str[3] = d
str[4] = \0

//포인터의 경우)
pString -> [ ABCD\0 ] 가리킴.




// 8. 포인터가 표현하는 문자열 상수 주의사항
char str1[5] = "abcd";
char *str2 = "ABCD";

printf("%s \n", str1); //문자열 변수 선언. abcd 출력
printf("%s \n", str2); //문자열 상수 선언. ABCD 출력

/* 문자열은 변수 앞에 *를 안붙여도 값이 존재한다. 배열자체가 주소를 가지기 때문에. */

str1[0] = 'x'; //문자열 변수 변경.
str2[0] = 'x'; //문자열 상수 변경. Error 발생!

printf("%s \n", str1); //xbcd출력
printf("%s \n", str2); //(Error)

// 각 문자열 맨 앞의 요소를 'x'로 바꾸는 코드이다.
//변수인 str1[5] 배열은 올바르게 x로 변환이 되었지만, 포인터는 변경이 불가능한 상수형태의 문자열로 에러가 발생한다.




// 9. 문자열 상수에 대한 조금 더 깊은 이해
<1.>
char *str = "ABCDEFG";
//문자열 상수는 메모리 공간에 할당되면 주소를 반환한다.
//(ABCDEFG를 메모리 공간에 저장 후, 그 주소값이 반환되어 포인터 str을 초기화하는것!)

<2.>
char *str1 = "Good!";
char *str2 = "Good!";

printf("%d, %d\n", str1, str2); //똑같은 주소값 출력

//(단, 반드시 정확하게 일치하는 문자열이여야 한다.)
//(일부 컴파일러에만 해당한다는것도 참고하기.)
//메모리를 효율적으로 사용하기 위한 메모리 최적화 때문에 이렇게 된다.





// 10. 포인터 배열
<1.>
int a = 10, b = 20, c = 30;
int *arr[3] = { &a,&b,&c }; //포인터 배열

printf("%d \n", *arr[0]); // arr[0]은 a를 가리킴. 10 출력.
printf("%d \n", *arr[1]); // arr[1]은 b를 가리킴. 20 출력.
printf("%d \n", *arr[2]); // arr[2]은 c를 가리킴. 30 출력.
						  // arr[3]은 \0(NULL)을 가리킴.

<2.>
char *arr[3] = { "Hello", "My name is", "James" };

printf("%s \n", arr[0]); //Hello 출력
printf("%s \n", arr[1]); //My name is 출력
printf("%s \n", arr[2]); //James 출력

//(문자열배열은 배열자체만으로 주소값을 가지고 있기 때문에, 앞에 *을 안넣어도 된다.)

char *arr[3] = { "Hello", "My name is", "James" };
char *arr[3] = { "0x1000", "0x2000", "0x3000" }; //이런식으로..
//(문자열 상수를 받는 즉시, 저장공간이 확보가 되고 주소값이 반환된다.)




// [ 총정리 ] //
1. 포인터 = 배열의 이름(첫번째 요소)
2. 포인터는 변수, 배열은 실수.
3. arr이 변수이름이던 포인터이던 "arr[i] = *(arr+i)" 는 항상 성립.
4. 포인터의 연산은 증가 혹은 감소만 되며 곱하기, 나누기는 불가능.
5. 포인터는 문자열 상수를 나타낼 수 있다.(문자열 상수의 특징)
6. 1차원 배열은 그 종류가 어떤 것이라도 배열 이름의 포인터타입이 무엇인지 알 수 있다. (int형 배열은 int형 포인터)